import {
  __commonJS
} from "./chunk-6TJCVOLN.js";

// browser-external:fs
var require_fs = __commonJS({
  "browser-external:fs"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "fs" has been externalized for browser compatibility. Cannot access "fs.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/convert-csv-to-json/src/util/fileUtils.js
var require_fileUtils = __commonJS({
  "node_modules/convert-csv-to-json/src/util/fileUtils.js"(exports, module) {
    "use strict";
    var fs = require_fs();
    var FileUtils = class {
      readFile(fileInputName, encoding) {
        return fs.readFileSync(fileInputName, encoding).toString();
      }
      writeFile(json, fileOutputName) {
        fs.writeFile(fileOutputName, json, function(err) {
          if (err) {
            throw err;
          } else {
            console.log("File saved: " + fileOutputName);
          }
        });
      }
    };
    module.exports = new FileUtils();
  }
});

// node_modules/convert-csv-to-json/src/util/stringUtils.js
var require_stringUtils = __commonJS({
  "node_modules/convert-csv-to-json/src/util/stringUtils.js"(exports, module) {
    "use strict";
    var StringUtils = class {
      trimPropertyName(value) {
        return value.replace(/\s/g, "");
      }
      getValueFormatByType(value) {
        if (value === void 0 || value === "") {
          return String();
        }
        let isNumber = !isNaN(value);
        if (isNumber) {
          return Number(value);
        }
        if (value === "true" || value === "false") {
          return JSON.parse(value.toLowerCase());
        }
        return String(value);
      }
      hasContent(values) {
        if (values.length > 0) {
          for (let i = 0; i < values.length; i++) {
            if (values[i]) {
              return true;
            }
          }
        }
        return false;
      }
    };
    module.exports = new StringUtils();
  }
});

// node_modules/convert-csv-to-json/src/util/jsonUtils.js
var require_jsonUtils = __commonJS({
  "node_modules/convert-csv-to-json/src/util/jsonUtils.js"(exports, module) {
    "use strict";
    var JsonUtil = class {
      validateJson(json) {
        try {
          JSON.parse(json);
        } catch (err) {
          throw Error("Parsed csv has generated an invalid json!!!\n" + err);
        }
      }
    };
    module.exports = new JsonUtil();
  }
});

// node_modules/convert-csv-to-json/src/csvToJson.js
var require_csvToJson = __commonJS({
  "node_modules/convert-csv-to-json/src/csvToJson.js"(exports, module) {
    "use strict";
    var fileUtils = require_fileUtils();
    var stringUtils = require_stringUtils();
    var jsonUtils = require_jsonUtils();
    var newLine = /\r?\n/;
    var defaultFieldDelimiter = ";";
    var CsvToJson = class {
      formatValueByType(active) {
        this.printValueFormatByType = active;
        return this;
      }
      supportQuotedField(active) {
        this.isSupportQuotedField = active;
        return this;
      }
      fieldDelimiter(delimiter) {
        this.delimiter = delimiter;
        return this;
      }
      indexHeader(indexHeader) {
        if (isNaN(indexHeader)) {
          throw new Error("The index Header must be a Number!");
        }
        this.indexHeader = indexHeader;
        return this;
      }
      parseSubArray(delimiter = "*", separator = ",") {
        this.parseSubArrayDelimiter = delimiter;
        this.parseSubArraySeparator = separator;
      }
      encoding(encoding) {
        this.encoding = encoding;
        return this;
      }
      generateJsonFileFromCsv(fileInputName, fileOutputName) {
        let jsonStringified = this.getJsonFromCsvStringified(fileInputName);
        fileUtils.writeFile(jsonStringified, fileOutputName);
      }
      getJsonFromCsvStringified(fileInputName) {
        let json = this.getJsonFromCsv(fileInputName);
        let jsonStringified = JSON.stringify(json, void 0, 1);
        jsonUtils.validateJson(jsonStringified);
        return jsonStringified;
      }
      getJsonFromCsv(fileInputName) {
        let parsedCsv = fileUtils.readFile(fileInputName, this.encoding);
        return this.csvToJson(parsedCsv);
      }
      csvStringToJson(csvString) {
        return this.csvToJson(csvString);
      }
      csvToJson(parsedCsv) {
        this.validateInputConfig();
        let lines = parsedCsv.split(newLine);
        let fieldDelimiter = this.getFieldDelimiter();
        let index = this.getIndexHeader();
        let headers = lines[index].split(fieldDelimiter);
        while (!stringUtils.hasContent(headers) && index <= lines.length) {
          index = index + 1;
          headers = lines[index].split(fieldDelimiter);
        }
        let jsonResult = [];
        for (let i = index + 1; i < lines.length; i++) {
          let currentLine;
          if (this.isSupportQuotedField) {
            currentLine = this.split(lines[i]);
          } else {
            currentLine = lines[i].split(fieldDelimiter);
          }
          if (stringUtils.hasContent(currentLine)) {
            jsonResult.push(this.buildJsonResult(headers, currentLine));
          }
        }
        return jsonResult;
      }
      getFieldDelimiter() {
        if (this.delimiter) {
          return this.delimiter;
        }
        return defaultFieldDelimiter;
      }
      getIndexHeader() {
        if (this.indexHeader !== null && !isNaN(this.indexHeader)) {
          return this.indexHeader;
        }
        return 0;
      }
      buildJsonResult(headers, currentLine) {
        let jsonObject = {};
        for (let j = 0; j < headers.length; j++) {
          let propertyName = stringUtils.trimPropertyName(headers[j]);
          let value = currentLine[j];
          if (this.isParseSubArray(value)) {
            value = this.buildJsonSubArray(value);
          }
          if (this.printValueFormatByType && !Array.isArray(value)) {
            value = stringUtils.getValueFormatByType(currentLine[j]);
          }
          jsonObject[propertyName] = value;
        }
        return jsonObject;
      }
      buildJsonSubArray(value) {
        let extractedValues = value.substring(
          value.indexOf(this.parseSubArrayDelimiter) + 1,
          value.lastIndexOf(this.parseSubArrayDelimiter)
        );
        extractedValues.trim();
        value = extractedValues.split(this.parseSubArraySeparator);
        if (this.printValueFormatByType) {
          for (let i = 0; i < value.length; i++) {
            value[i] = stringUtils.getValueFormatByType(value[i]);
          }
        }
        return value;
      }
      isParseSubArray(value) {
        if (this.parseSubArrayDelimiter) {
          if (value && (value.indexOf(this.parseSubArrayDelimiter) === 0 && value.lastIndexOf(this.parseSubArrayDelimiter) === value.length - 1)) {
            return true;
          }
        }
        return false;
      }
      validateInputConfig() {
        if (this.isSupportQuotedField) {
          if (this.getFieldDelimiter() === '"') {
            throw new Error('When SupportQuotedFields is enabled you cannot defined the field delimiter as quote -> ["]');
          }
          if (this.parseSubArraySeparator === '"') {
            throw new Error('When SupportQuotedFields is enabled you cannot defined the field parseSubArraySeparator as quote -> ["]');
          }
          if (this.parseSubArrayDelimiter === '"') {
            throw new Error('When SupportQuotedFields is enabled you cannot defined the field parseSubArrayDelimiter as quote -> ["]');
          }
        }
      }
      hasQuotes(line) {
        return line.includes('"');
      }
      split(line) {
        if (line.length == 0) {
          return [];
        }
        let delim = this.getFieldDelimiter();
        let subSplits = [""];
        if (this.hasQuotes(line)) {
          let chars = line.split("");
          let subIndex = 0;
          let startQuote = false;
          let isDouble = false;
          chars.forEach((c, i, arr) => {
            if (isDouble) {
              subSplits[subIndex] += c;
              isDouble = false;
              return;
            }
            if (c != '"' && c != delim) {
              subSplits[subIndex] += c;
            } else if (c == delim && startQuote) {
              subSplits[subIndex] += c;
            } else if (c == delim) {
              subIndex++;
              subSplits[subIndex] = "";
              return;
            } else {
              if (arr[i + 1] === '"') {
                isDouble = true;
              } else {
                if (!startQuote) {
                  startQuote = true;
                } else {
                  startQuote = false;
                }
              }
            }
          });
          if (startQuote) {
            throw new Error("Row contains mismatched quotes!");
          }
          return subSplits;
        } else {
          return line.split(delim);
        }
      }
    };
    module.exports = new CsvToJson();
  }
});

// node_modules/convert-csv-to-json/index.js
var require_convert_csv_to_json = __commonJS({
  "node_modules/convert-csv-to-json/index.js"(exports) {
    var csvToJson = require_csvToJson();
    var encodingOps = {
      utf8: "utf8",
      ucs2: "ucs2",
      utf16le: "utf16le",
      latin1: "latin1",
      ascii: "ascii",
      base64: "base64",
      hex: "hex"
    };
    exports.formatValueByType = function(active = true) {
      csvToJson.formatValueByType(active);
      return this;
    };
    exports.supportQuotedField = function(active = false) {
      csvToJson.supportQuotedField(active);
      return this;
    };
    exports.fieldDelimiter = function(delimiter) {
      csvToJson.fieldDelimiter(delimiter);
      return this;
    };
    exports.indexHeader = function(index) {
      csvToJson.indexHeader(index);
      return this;
    };
    exports.parseSubArray = function(delimiter, separator) {
      csvToJson.parseSubArray(delimiter, separator);
      return this;
    };
    exports.customEncoding = function(encoding) {
      csvToJson.encoding = encoding;
      return this;
    };
    exports.utf8Encoding = function utf8Encoding() {
      csvToJson.encoding = encodingOps.utf8;
      return this;
    };
    exports.ucs2Encoding = function() {
      csvToJson.encoding = encodingOps.ucs2;
      return this;
    };
    exports.utf16leEncoding = function() {
      csvToJson.encoding = encodingOps.utf16le;
      return this;
    };
    exports.latin1Encoding = function() {
      csvToJson.encoding = encodingOps.latin1;
      return this;
    };
    exports.asciiEncoding = function() {
      csvToJson.encoding = encodingOps.ascii;
      return this;
    };
    exports.base64Encoding = function() {
      this.csvToJson = encodingOps.base64;
      return this;
    };
    exports.hexEncoding = function() {
      this.csvToJson = encodingOps.hex;
      return this;
    };
    exports.generateJsonFileFromCsv = function(inputFileName, outputFileName) {
      if (!inputFileName) {
        throw new Error("inputFileName is not defined!!!");
      }
      if (!outputFileName) {
        throw new Error("outputFileName is not defined!!!");
      }
      csvToJson.generateJsonFileFromCsv(inputFileName, outputFileName);
    };
    exports.getJsonFromCsv = function(inputFileName) {
      if (!inputFileName) {
        throw new Error("inputFileName is not defined!!!");
      }
      return csvToJson.getJsonFromCsv(inputFileName);
    };
    exports.csvStringToJson = function(csvString) {
      return csvToJson.csvStringToJson(csvString);
    };
    exports.jsonToCsv = function(inputFileName, outputFileName) {
      csvToJson.generateJsonFileFromCsv(inputFileName, outputFileName);
    };
  }
});
export default require_convert_csv_to_json();
//# sourceMappingURL=convert-csv-to-json.js.map
