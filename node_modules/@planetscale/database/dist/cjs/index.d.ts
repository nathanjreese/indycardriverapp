export { format } from './sanitization.js';
export { hex } from './text.js';
type Row<T extends ExecuteAs = 'object'> = T extends 'array' ? any[] : T extends 'object' ? Record<string, any> : never;
interface VitessError {
    message: string;
    code: string;
}
export declare class DatabaseError extends Error {
    body: VitessError;
    status: number;
    constructor(message: string, status: number, body: VitessError);
}
type Types = Record<string, string>;
export interface ExecutedQuery<T = Row<'array'> | Row<'object'>> {
    headers: string[];
    types: Types;
    rows: T[];
    fields: Field[];
    size: number;
    statement: string;
    insertId: string;
    rowsAffected: number;
    time: number;
}
type Req = {
    method: string;
    headers: Record<string, string>;
    body: string;
    cache?: RequestCache;
};
type Res = {
    ok: boolean;
    status: number;
    statusText: string;
    json(): Promise<any>;
    text(): Promise<string>;
};
export type Cast = typeof cast;
export interface Config {
    url?: string;
    username?: string;
    password?: string;
    host?: string;
    fetch?: (input: string, init?: Req) => Promise<Res>;
    format?: (query: string, args: any) => string;
    cast?: Cast;
}
export interface Field {
    name: string;
    type: string;
    table?: string;
    orgTable?: string | null;
    database?: string | null;
    orgName?: string | null;
    columnLength?: number | null;
    charset?: number | null;
    flags?: number | null;
    columnType?: string | null;
}
type ExecuteAs = 'array' | 'object';
type ExecuteArgs = object | any[] | null;
export declare class Client {
    readonly config: Config;
    constructor(config: Config);
    transaction<T>(fn: (tx: Transaction) => Promise<T>): Promise<T>;
    execute<T = Row<'object'>>(query: string, args?: ExecuteArgs, options?: {
        as?: 'object';
        cast?: Cast;
    }): Promise<ExecutedQuery<T>>;
    execute<T = Row<'array'>>(query: string, args: ExecuteArgs, options: {
        as: 'array';
        cast?: Cast;
    }): Promise<ExecutedQuery<T>>;
    connection(): Connection;
}
export type Transaction = Tx;
declare class Tx {
    private conn;
    constructor(conn: Connection);
    execute<T = Row<'object'>>(query: string, args?: ExecuteArgs, options?: {
        as?: 'object';
        cast?: Cast;
    }): Promise<ExecutedQuery<T>>;
    execute<T = Row<'array'>>(query: string, args: ExecuteArgs, options: {
        as: 'array';
        cast?: Cast;
    }): Promise<ExecutedQuery<T>>;
}
export declare class Connection {
    readonly config: Config;
    private session;
    private url;
    constructor(config: Config);
    transaction<T>(fn: (tx: Transaction) => Promise<T>): Promise<T>;
    refresh(): Promise<void>;
    execute<T = Row<'object'>>(query: string, args?: ExecuteArgs, options?: {
        as?: 'object';
        cast?: Cast;
    }): Promise<ExecutedQuery<T>>;
    execute<T = Row<'array'>>(query: string, args: ExecuteArgs, options: {
        as: 'array';
        cast?: Cast;
    }): Promise<ExecutedQuery<T>>;
    private createSession;
}
export declare function connect(config: Config): Connection;
export declare function cast(field: Field, value: string | null): any;
